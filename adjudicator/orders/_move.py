""" The Move class"""from yaml import load, Loaderfrom adjudicator.orders.lib import Orderwith open('adjudicator/config.yaml', 'r') as file:    RELEVANCE = load(file, Loader)['relevance']class Move(Order):    """ A Move is an order for to a unit to change its location.    Attributes:    name : string        class attribute: 'hold'            relevance : intger            The relevance of the move relative other types of orders; sorting            by relevance gives a faster adjudication process.        unit : Unit            The unit the order is given to.        province : Province            The current province of the unit.        target : Location            The target location of the move.        convoy : boolean            Whether the move is via convoy or not.        statuses : dictionary            Dictionary of statuses and their ordering.        max_status : string            The maximal status of the move as currently known.        min_status : string            The minimal status of the move as currently known.        max_hold : integer            The maximal hold strength of the unit.        min_hold : integer            The minimal hold strength of the unit.        max_move : dictionary            A dictionary of maximal move strengths when including all supports            or exluding supports of certain powers.        min_move : dictionary            A dictionary of minimal move strengths when including all supports            or exluding supports of certain powers.        cutting : boolean or None            Whether the move cuts support or not.        dislodging : boolean or None            Whether the move may dislodge a unit.        failed : boolean or None            Whether the move fails or not.        resolved : boolean or None            Whether the move is resolved or not.    """    relevance = RELEVANCE['move']    max_hold = 1    min_hold = 1    name = 'move'    def __init__(self, unit, convoy, target, max_move=34):        """ The constructor for the Move class.        Parameters        ----------        unit : Unit        convoy : boolean        target : Location        """        self.unit = unit        self.convoy = convoy        self.target = target        self.max_status = 'valid'        self.min_status = 'illegal'        self.cutting = None        self.dislodging = None        self.failed = None        self.max_move = {None: 34}        self.min_move = {None: 1}                # The province should not by dynamically updated        # if the unit is moved during the execution phase.        self.province = unit.location.province    def __str__(self, context='self'):        """ Print method.        """        routes = {False: 'move', True: 'move via convoy'}        resolutions = {True: '(fails)', False: '(succeeds)',                       None: '[unresolved]'}        if context == 'self':            return (f'{self.unit.__str__("")} {routes[(self.convoy)]} to '                    f'{self.target.name} {resolutions[self.failed]}.')        elif context == 'support':            return (f'the move {self.unit.location.name} to '                    f'{self.target.province.name}')        elif context == 'convoy':            return f'{self.unit.location.name} to {self.target.name}'    def reset(self):        """ Reset to the initial attribute values.        """        del self.max_status, self.min_status        self.max_status = 'valid'        self.min_status = 'illegal'        self.cutting = None        self.dislodging = None        self.failed = None        self.max_move = {None: 34}        self.min_move = {None: 1}    def set_illegal(self):        """ Method to set a move to illegal.        """        self.max_status = 'illegal'        self.set_('cutting', False)        self.set_('dislodging', False)        self.set_('failed', True)        for entry in self.min_move.keys():            self.min_move[entry] = 0        for entry in self.max_move.keys():            self.max_move[entry] = 0    @property    def resolved(self):        """ Method to set a move to resolved.        """        param = None not in [self.cutting, self.dislodging, self.failed]                return (self.__resolved__('status')                and self.__resolved__('move')                 and param)            @property    def province(self):        """ province getter.                """        return self._province        @province.setter    def province(self, value):        """ province setter.                """        if not hasattr(self, '_province'):            self._province = value    def __adjacent_convoy__(self, orders):        """ Method to employ a rule variation for adjacent convoys.                """        # webDip Convoy Rule, light version        adjacent_convoys = [order for order in orders.aids(self, 'convoy')                            if order.unit.location.reaches_province(self.unit.province)]        if self.convoy and (len(adjacent_convoys) == 0):            self.convoy = False            def __object_equivalent__(self, order):        """ Method to check whether the instance is equivalent to an order        as objects of other orders.        """        return (isinstance(order, Move)                and order.province is self.province                and order.target.province is self.target.province)    def __compute_move_strengths__(self, powers, orders):        """ Method to compute move strength, and the modified move strengths        when supports of a certain power are discounted.        Parameters        ----------        powers : list of Powers        orders : list of Orders            The list of order from which we should retrieve support orders.        """        supports = orders.aids(self, 'support')        # We need to keep track of the powers giving the supports, to be        # able to compute the adjusted move strengths.        possible = [order.unit.owner for order in supports                    if order.max_status == 'valid']        known = [order.unit.owner for order in supports                 if order.min_status == 'valid']        self.max_move[None] = 1 + len(possible)        self.min_move[None] = 1 + len(known)        # Computing the adjusted move strengths.        for power in powers:            self.max_move[power] = self.max_move[None] - possible.count(power)            self.min_move[power] = self.min_move[None] - known.count(power)    def moves(self):        """ Method to check whether the move will take place.                """        return self.min_status == 'valid' and not self.failed    def __convoy__(self, map_, orders, attr):        """ Method to check whether a convoy route exists.        """        locations = [order.unit.location for order in orders.aids(self, 'convoy')                     if getattr(order, attr) == 'valid']        return map_.has_path(self.province, self.target.province, locations)    def __repels__(self, order):        """ Method to check whether an order is a move away from the target        province of self.        """        if order is None or not isinstance(order, Move):            return False        elif (self.convoy or order.convoy              or order.target.province is not self.unit.province):            return True        else:            return False    def __opposed_by__(self, order):        """ Method to check whether an order is a move head-to-head with self.        """        if (not isinstance(order, Move)            or self.convoy            or order.convoy            or order.target.province is not self.province            or order.max_status == 'illegal'):            return False        else:            return True    def blocks(self):        """ Method to retrieve the provinces blocked by self during the        retreat phase. Returns a list of provinces.        """        if self.max_status < 'valid':            return [self.province]        elif not self.failed:            return [self.target.province]        else:            return [self.province, self.target.province]    def __supports_attack_on_self__(self, order):        """ Method to check whether an order supports an attack on the source        province of self.        """        return (order.name == 'support'                and order.__supports_move_on__(self.province))    def __stronger_than__(self, orders, except_power):        """ Method to check whether the move is the strongest move order        amongst a set of orders, discounting support by except_power.        Parameters:        -----------        orders : list of Moves        except_power : Power        """        if len(orders) == 0:            return True        opponent = max([order.max_move[None] for order in orders])        return self.min_move[except_power] > opponent    def __weaker_than__(self, orders, except_power):        """ Method to check whether the move is weaker (or equal in strength)        than some move order amongst a set of orders, discounting possible        support by except_power.        Parameters        ----------        orders : list of Moves        except_power : Power        """        if len(orders) == 0:            return False        opponent = max([order.min_move[None] for order in orders])        return self.max_move[except_power] <= opponent    def __stronger_attack__(self, order, except_power):        """ Method to check whether the move is stronger than the hold        strength of the unit of an order.        """        return self.min_move[except_power] > order.max_hold    def __weaker_attack__(self, order, except_power):        """ Method to check whether the move is weaker (or eaqual in strength)        to the hold strength of the unit of an order.        """        return self.max_move[except_power] <= order.min_hold    def __bounces__(self, orders, except_entry=None):        """ Method to check whether the move is bounced by other moves,        discounting the support of except_power.        """        try:            except_power = except_entry.unit.owner        except (AttributeError):            except_power = None        possible = [order for order in orders if isinstance(order, Move)                    and order.target.province is self.target.province                    and order is not self                    and order.max_status == 'valid']        known = [order for order in possible if order.min_status == 'valid']        if self.__stronger_than__(possible, except_power):            return False        if self.__weaker_than__(known, except_power):            return True        return None  # Encoding that the bounce remains unresolved    def __attacks__(self, orders, attacked):        """ Method to check whether the attack is successful in dislodging        the defending unit.        """        if attacked.unit.owner == self.unit.owner:            return False        if self.__stronger_attack__(attacked, attacked.unit.owner):            return True        if self.__weaker_attack__(attacked, attacked.unit.owner):            return False        return None  # Encoding that the attack remains unresolved    def __resolve_legality__(self, game_map, orders):        """ Method to resolve the legality of a move order.        """        if not self.convoy:            if self.unit.location.reaches_location(self.target):                self.min_status = 'no effect'            else:                self.set_illegal()        else:            if self.__convoy__(game_map, orders, 'min_status'):                self.min_status = 'valid'            elif not self.__convoy__(game_map, orders, 'max_status'):                self.set_illegal()            # If neither, then legality cannot yet be determined.    def __resolve_hth__(self, attacked, except_=None):        """ Method to resolve the outcome of a head to head battle.        """        if attacked.min_status == 'illegal':            # Cannot resolve if opponent has not been deemed a legal order.            return None        if attacked.unit.owner == self.unit.owner:            return False        elif self.__stronger_than__([attacked], except_):            return True        elif self.__weaker_than__([attacked], except_):            return False        else:            return None    def resolve(self, variant, orders):        """ Main method to resolve a move order.        """        if self.min_status == 'illegal':            self.__resolve_legality__(variant.map, orders)        if self.min_status > 'illegal':            if not self.__resolved__('move'):                self.__compute_move_strengths__(variant.powers, orders)                            attacked = next((order for order in orders                             if order.province is self.target.province), None)            if attacked is None:                self.__resolve_empty__(orders, attacked)            elif self.__repels__(attacked):                self.__resolve_repels____(orders, attacked)            elif self.__opposed_by__(attacked):                self.__resolve_opposed__(orders, attacked)            elif self.__supports_attack_on_self__(attacked):                self.__resolve_support_on_self__(orders, attacked)            else:                self.__resolve_attack__(orders, attacked)    def __resolve_empty__(self, orders, attacked_order):        """ Method to resolve a move into an empty or emptied province.        """        self.min_status = 'valid'        bounced = self.__bounces__(orders, None)        self.set_('cutting', False)  # Doesn't matter, nothing to cut        self.set_('dislodging', False)  # Doesn't matter, nothing to dislodge        self.set_('failed', bounced)    def __resolve_repels____(self, orders, attacked_order):        """ Method to resolve a move into possibly emptied province. Even if        the move of the unit in the target province is not resolved, we might        still be able to resolve bounces, etc.        """        self.min_status = 'valid'        self.set_('cutting', False)        if attacked_order.failed is False:            self.__resolve_empty__(orders, attacked_order)        elif attacked_order.failed is True:            self.__resolve_attack__(orders, attacked_order)        elif self.__bounces__(orders, None):            self.set_('dislodging', False)            self.set_('failed', True)    def __resolve_opposed__(self, orders, attacked):        """ Method to resolve a head-to-head battle.        """        self.set_('cutting', False)        bounced = self.__bounces__(orders, attacked)        win_hth = self.__resolve_hth__(attacked)        mod_hth = self.__resolve_hth__(attacked, attacked.unit.owner)        if attacked.min_status == 'illegal':            pass        elif attacked.failed is False:            self.max_status = 'no effect'            self.set_('dislodging', False)            self.set_('failed', True)        elif attacked.failed is True:            self.min_status = 'valid'            if (bounced is not None) and (mod_hth is not None):                self.set_('dislodging', (not bounced) and mod_hth)                self.set_('failed', bounced or not mod_hth)        elif win_hth is True:            self.min_status = 'valid'            if bounced is not None and mod_hth is not None:                self.set_('dislodging', not bounced and mod_hth)                self.set_('failed', bounced or not mod_hth)        elif win_hth is False:            # Status will depend on whether opposing order bounces.            self.set_('dislodging', False)            self.set_('failed', True)    def __resolve_support_on_self__(self, orders, attacked_order):        """ Method to resolve a move onto a unit supporting an attack on the        source province.        """        self.min_status = 'valid'        if self.dislodging is False:  # Safety measure            self.set_('cutting', False)            self.set_('failed', True)        attack = self.__attacks__(orders, attacked_order)        bounced = self.__bounces__(orders, attacked_order)        if bounced is None or attack is None:            return None        self.set_('cutting', not bounced and attack)        self.set_('dislodging', not bounced and attack)        self.set_('failed', bounced or not attack)    def __resolve_attack__(self, orders, attacked_order):        """ Method to resolve a move into a privince with a defending unit.        """        self.min_status = 'valid'        self.set_('cutting', True)        if self.dislodging is False:            self.set_('failed', True)        attack = self.__attacks__(orders, attacked_order)        bounced = self.__bounces__(orders, attacked_order)        if bounced is None or attack is None:            return None        self.set_('dislodging', not bounced and attack)        self.set_('failed', bounced or not attack)